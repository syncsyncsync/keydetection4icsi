

# Keypoint Detection on ICSI 


## システム概要
本マニュアルでは、顕微受精（ICSI）における精子のキーポイント検出を行うオープンソースプロジェクト「keydetection4icsi」のインストール方法と基本的な使い方について説明します。キーポイント検出には、Detectron2のキーポイント検出を使用しています。
事前学習済みのデータを付属していますが、簡易的なものですので再学習が必要です。


## システム要件
Python 3.x
Detectron2
PyTorch
torchvision
OpenCV
Numpy


## インストール方法
keydetection4icsiを利用するために必要なパッケージをインストールします。
以下のコマンドを実行してください。

```shell
pip install torch torchvision
pip install opencv-python
pip install numpy
```

次に、Detectron2をインストールします。公式ドキュメント（https://detectron2.readthedocs.io/en/latest/tutorials/install.html）に従い、適切なバージョンをインストールしてください。
最後に、GitHubリポジトリからkeydetection4icsiをダウンロードします。


##  顕微受精キーポイント検出（keydetection4icsi
ここでは顕微受精（ICSI）における精子のキーポイント検出を行うオープンソースプロジェクト「keydetection4icsi」のインストール方法と基本的な使い方について説明します。キーポイント検出には、Detectron2を使用しています。事前学習済みのデータを用意していますが、簡易的なものですので再学習が必要です。

システム要件
Python 3.x
Detectron2
PyTorch
torchvision
OpenCV
Numpy
インストール方法
keydetection4icsiを利用するためには、まず必要なパッケージをインストールします。以下のコマンドを実行してください。
Copy code
pip install torch torchvision
pip install opencv-python
pip install numpy
次に、Detectron2をインストールします。公式ドキュメント（https://detectron2.readthedocs.io/en/latest/tutorials/install.html）に従い、適切なバージョンをインストールしてください。

最後に、GitHubリポジトリからkeydetection4icsiをダウンロードします。

'''bash
Copy code
git clone https://github.com/syncsyncsync/keydetection4icsi.git
cd keydetection4icsi
'''

a) 顕微鏡画像の準備
顕微鏡で撮影した精子の画像を用意します。画像はPNG、JPG、BMP等の一般的なフォーマットに対応しています。

b) キーポイント検出の実行
用意した画像ファイル（例：sample.jpg）を指定して、以下のコマンドを実行します。

python keypoint_detection.py --input_image sample.jpg

### 結果の確認
検出されたキーポイントが画像上にマークされ、表示されます。また、検出結果はテキストファイルとして保存されます。



## 概要
このプログラムは、COCOデータセットのキーポイントを学習し、ICSIデータセット上でのキーポイント検出を行います。デフォルトでDetectron2を使用しており、データオーギュメンテーションを追加することで、性能を向上させています。

## ライブラリとパッケージ

- ROS: ロボットオペレーティングシステム
- numpy: 数値計算
- cv2: 画像処理
- matplotlib: グラフ描画
- scipy: 科学技術計算
- argparse: コマンドライン引数
- detectron2: 物体検出
- sensor_msgs: ROSメッセージ
- geometry_msgs: ROSメッセージ
- cv_bridge: ROSとOpenCV間の変換

## 主な機能

- **データオーギュメンテーション**: 学習データに対してランダムな明るさ、コントラスト、反転、クロップ、回転などの変換を適用し、学習データを拡張します。
- **MyTrainerクラス**: DefaultTrainerを継承し、データオーギュメンテーションを組み込んだカスタムトレーナーを実装します。
- **SPVisualizerクラス**: Visualizerを継承し、キーポイントの可視化をカスタマイズしたクラスを実装します。
- **register_dataset関数**: データセットを登録する関数です。データセットが既に登録されている場合は、再登録を行わずメッセージを表示します。forceオプションをTrueにすると、強制的にデータセットを再登録します。

## 使用方法

1. 必要なライブラリとパッケージをインストールします。
2. このプログラムを実行する前に、続きのコードを用意してください。
3. プログラムを実行し、ICSIデータセット上でのキーポイント検出を行います。

注意: このマニュアルはコードの続きがあることを前提に記載しています。続きのコードがない場合、このプログラムは正常に機能しない場合があります。


## predict関数の説明
predict関数は、画像やビデオストリーム内のオブジェクトのキーポイントを検出するために使用されます。検出されたキーポイントは、画像として可視化され、リアルタイムで出力されます。この関数は、ROS (Robot Operating System) モードで動作することもできます。

### 引数

cfg : 設定オブジェクト。
image_path : 入力画像のパス。
model_weight : モデルの重みファイルのパス。
config_file : 設定ファイルのパス。デフォルトは DETECT_config1。
sample : サンプル数。デフォルトは 10。
output_dir : 出力ディレクトリ。デフォルトは "pred"。
device : 使用するデバイス。デフォルトは "cuda"。
video : ビデオファイルのパス。デフォルトは "tst.avi"。
sub_image_node : サブスクライバーイメージノード。デフォルトは "/sperm_test_image/image_raw"。
mode : 動作モード。デフォルトは "ROS"。
fps : フレームレート。デフォルトは DEFAULT_FPS。

### 使用方法

必要なパラメータを設定して、predict関数を呼び出します。
関数は、入力画像やビデオストリームからオブジェクトのキーポイントを検出し、画像として可視化します。
画像は、出力ディレクトリに保存されます。
モードに応じて、ROS またはビデオモードで処理が行われます。


### select_best_candidate関数
select_best_candidate関数は、与えられたマッチングデータ（ボックス、キー、スコア、速度）をもとに、最適な候補の選択を行います。この関数は、特定の条件に基づいてマッチングデータの絞り込みを行い、最終的に選択された候補のデータを返します。

具体的な処理の流れは以下の通りです。

まず、matched_boxesが空の場合は、入力されたマッチングデータをそのまま返します。
matched_scoresを用いて、要素を降順にソート（スコアが高い順）します。
上位top_k[0]（デフォルトでは5）個の要素を保持し、それ以外の要素を除外します。
続いて、matched_velocitiesを用いて、要素を降順にソート（速度が高い順）します。
速度が120を超える要素は除外します。
上位top_k[1]（デフォルトでは4）個の要素を保持し、それ以外の要素を除外します。
最終的に、選択されたマッチングデータ（ボックス、キー、スコア、速度）を返します。

この関数は、物体検出や追跡などのアプリケーションで、複数の候補が存在する場合に、最適な候補を効率的に選択するために使用されます。また、指定されたメトリック（デフォルトでは'score'）と上位k個の要素に基づいて絞り込みを行い、アプリケーションの性能を向上させることができます。


### 引数

matched_boxes: numpy.ndarray。マッチングされたボックスのリスト。
matched_keys: numpy.ndarray。マッチングされたキーのリスト。
matched_scores: numpy.ndarray。マッチングされたスコアのリスト。
matched_velocities: numpy.ndarray。マッチングされた速度のリスト。
metric: str。使用するメトリック。現在は'score'のみサポートされています。
top_k: list。上位k個の要素を選択するためのリスト。デフォルトでは[5, 4]。


### 返り値

matched_boxes: numpy.ndarray。選択されたボックスのリスト。
matched_keys: numpy.ndarray。選択されたキーのリスト。
matched_scores: numpy.ndarray。選択されたスコアのリスト。
matched_velocities: numpy.ndarray。選択された速度のリスト。


### 処理の流れ

アルゴリズムの主な目的は、マッチングデータ（ボックス、キー、スコア、速度）をもとに、最適な候補を選択することです。このアルゴリズムは、スコアや速度の情報を利用して、複数のフィルタリングステージを経ることで、最適な候補を選択します。

アルゴリズムの手順は以下の通りです。

1. スコアによるソート: まず、マッチングされたスコアに基づいて、降順（スコアが高い順）にソートします。このステージでは、信頼性の高い候補を選択することが目的です。
2. 上位k個の候補の選択（1st stage）: スコアが高い順にソートされた候補から、上位top_k[0]（デフォルトでは5）個の候補を選択します。このステージでは、スコアに基づいて最も信頼性の高い候補を選択します。
3. 速度によるソート: 次に、マッチングされた速度に基づいて、降順（速度が高い順）にソートします。このステージでは、動いている物体を優先的に選択することが目的です。
4. 速度フィルタリング: 速度が一定の閾値（例：120）を超える候補は、速度が大きすぎると判断し、除外します。これにより、過剰な速度の候補を排除することができます。
5. 上位k個の候補の選択（2nd stage）: 速度が高い順にソートされた候補から、上位top_k[1]（デフォルトでは4）個の候補を選択します。このステージでは、速度に基づいて最も適切な候補を選択します。
6. 最適な候補の選択: これらのフィルタリングステージを経て選択された候補が、最適な候補として返されます。このアルゴリズムによって、スコアと速度の両方に基づいて、物体検出や追跡タスクで最適な候補が選択されます。

このアルゴリズムの利点は、複数の基準（スコアと速度）を組み合わせることで、最適な候補を効率的に選択できる点です。また、フィルタリングのステージを2つに分けることで、異なる基準に基づいて候補を絞り込むことができます。これにより、物体検出や追跡タスクの性能が向上し、精度の高い結果が得られます。

このアルゴリズムは、データセットやアプリケーションに応じて、フィルタリングの閾値や上位k個の値を調整することで、さらに最適化することが可能です。アプリケーションの特性や要件に合わせて、パラメータをチューニングすることで、最適な候補選択を実現できます。

 * パラメータの調整: 上位k個の値や速度の閾値など、アルゴリズムにおけるパラメータが固定されています。異なるデータセットやアプリケーションに対して最適な結果を得るためには、これらのパラメータを適切に調整する必要があります。パラメータの調整が不十分な場合、適切な候補が選択されず、性能が低下する可能性があります。
* ヒューリスティックなアプローチ: このアルゴリズムはヒューリスティックなアプローチを採用しており、最適な候補の選択はスコアと速度の情報に基づいています。このため、他の重要な特徴が考慮されない場合があります。複雑なシーンや状況に対応するには、より高度なアルゴリズムや機械学習モデルを使用することが望ましいでしょう。
* 計算コスト: アルゴリズムの複数のフィルタリングステージで、ソートやフィルタリングが繰り返し行われます。大規模なデータセットや高速なリアルタイム処理が必要な場合、計算コストが高くなる可能性があります。効率的なアルゴリズムを検討することで、計算コストを削減することができます。
* ロバスト性の欠如: このアルゴリズムは、スコアや速度に大きく依存しています。これらの値がノイズによって大きく影響を受ける場合、適切な候補が選択されない可能性があります。ノイズの影響を抑えるために、ロバストなアルゴリズムや前処理手法を検討することが重要です。


## visualize_candidate 関数の詳細な説明

### 概要
`visualize_candidate`関数は、マッチングされたボックス、キー、スコア、速度を元に、候補の可視化を行います。関数は、画像に候補のボックス、キー、スコア、速度を描画し、最終的な画像を指定されたディレクトリに保存します。

### 引数

- `im`: numpy.ndarray。処理対象の画像。
- `matched_boxes`: numpy.ndarray。マッチングされたボックスのリスト。
- `matched_keys`: numpy.ndarray。マッチングされたキーのリスト。
- `matched_scores`: numpy.ndarray。マッチングされたスコアのリスト。
- `matched_velocities`: numpy.ndarray。マッチングされた速度のリスト。
- `output_dir`: str。画像を保存するディレクトリのパス。
- `frame_id`: int。フレームID。
- `score_th`: float。スコアの閾値（デフォルトでは0.4）。

### 処理の流れ

1. 画像のサイズと中心点を取得します。
2. 各マッチングデータに対して、以下の処理を行います。
   - スコアが閾値以下の場合、処理をスキップします。
   - ボックスが画像の範囲外の場合、処理をスキップします。
   - ボックスのインデックス、スコア、速度を描画します。
   - キーに基づいて矩形を描画します。
3. 画像をリサイズして、指定されたディレクトリに保存します。