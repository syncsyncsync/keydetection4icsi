

# Keypoint Detection on ICSI  
japanese version

## システム概要
本マニュアルでは、顕微受精（ICSI）における精子のキーポイント検出を行うオープンソースプロジェクト「keydetection4icsi」のインストール方法と基本的な使い方について説明します。キーポイント検出には、Detectron2のキーポイント検出を使用しています。
事前学習済みのデータを付属していますが、簡易的なものですので再学習が必要です。


## システム要件

### 関連ライブラリとパッケージ
- ROS: ロボットオペレーティングシステム
- numpy: 数値計算
- cv2: 画像処理
- matplotlib: グラフ描画
- scipy: 科学技術計算
- argparse: コマンドライン引数
- detectron2: 物体検出
- sensor_msgs: ROSメッセージ
- geometry_msgs: ROSメッセージ
- cv_bridge: ROSとOpenCV間の変換

### インストール方法
1) keydetection4icsiを利用するために必要なパッケージをインストールします。
以下のコマンドを実行してください。

```shell
pip install torch torchvision
pip install opencv-python
pip install numpy
```

2) 次に、Detectron2をインストールします。公式ドキュメント（https://detectron2.readthedocs.io/en/latest/tutorials/install.html）に従い、適切なバージョンをインストールしてください。
最後に、GitHubリポジトリからkeydetection4icsiをダウンロードします。

```bash
# Copy code
git clone https://github.com/syncsyncsync/keydetection4icsi.git
cd keydetection4icsi
```

## 主な機能

- **データオーギュメンテーション**: 学習データに対してランダムな明るさ、コントラスト、反転、クロップ、回転などの変換を適用し、学習データを拡張します。
- **MyTrainerクラス**: DefaultTrainerを継承し、データオーギュメンテーションを組み込んだカスタムトレーナーを実装します。
- **SPVisualizerクラス**: Visualizerを継承し、キーポイントの可視化をカスタマイズしたクラスを実装します。
- **register_dataset関数**: データセットを登録する関数です。データセットが既に登録されている場合は、再登録を行わずメッセージを表示します。forceオプションをTrueにすると、強制的にデータセットを再登録します。

- **predict関数の説明**
predict関数は、画像やビデオストリーム内のオブジェクトのキーポイントを検出するために使用されます。検出されたキーポイントは、画像として可視化され、リアルタイムで出力されます。この関数は、ROS (Robot Operating System) モードで動作することもできます。
   -  **引数**
   ```
   cfg : 設定オブジェクト。
   image_path : 入力画像のパス。
   model_weight : モデルの重みファイルのパス。
   config_file : 設定ファイルのパス。デフォルトは DETECT_config1。
   sample : サンプル数。デフォルトは 10。
   output_dir : 出力ディレクトリ。デフォルトは "pred"。
   device : 使用するデバイス。デフォルトは "cuda"。
   video : ビデオファイルのパス。デフォルトは "tst.avi"。
   sub_image_node : サブスクライバーイメージノード。デフォルトは "/sperm_test_image/image_raw"。
   mode : 動作モード。デフォルトは "ROS"。
   fps : フレームレート。デフォルトは DEFAULT_FPS。
``


### 使用方法
必要なパラメータを設定して、predict関数を呼び出します。
関数は、入力画像やビデオストリームからオブジェクトのキーポイントを検出し、画像として可視化します。
画像は、出力ディレクトリに保存されます。モードに応じて、ROS またはビデオモードで処理が行われます。


## 詳細

### **test_callback_ros** 関数
この関数は、顕微鏡画像から精子の位置とキーポイントを検出し、それらの変位速度を計算するものです。test_callback_ros関数は以下の引数を持ちます。

im：入力画像
fps：フレームレート（デフォルト値：DEFAULT_FPS）
METRIC：マッチングアルゴリズムに使用する距離指標（'iou'、'dist'、'hybrid'）
hybrid_lambda：ハイブリッド距離指標の重み付け（0から1の範囲、デフォルト値：0.7）
関数は以下の手順で処理を行います。

入力画像をDetectron2を用いてキーポイント検出を行い、検出されたバウンディングボックスとキーポイントを取得します。
前フレームと現フレームのバウンディングボックスとキーポイント間の距離行列およびIoU（Intersection over Union）行列を計算します。
ハンガリアンアルゴリズムを用いて、前フレームと現フレームのバウンディングボックスとキーポイントのマッチングを行います。
マッチングされたバウンディングボックス間の変位速度を計算します。
マッチングされたバウンディングボックスとキーポイントを速度でソートし、関数の戻り値として返します。
関数の戻り値は以下の4つの要素を含むタプルです。

matched_boxes：マッチングされたバウンディングボックスのペア
matched_keys：マッチングされたキーポイントのペア
scores：マッチングされたバウンディングボックスおよびキーポイントの信頼スコア
matched_velocities：マッチングされたバウンディングボックス間の変位速度
この関数は、精子の追跡と分析に役立つ情報を提供することができます。例えば、速度に基づいて精子を分類したり、特定のキーポイントが動いている速度を調べたりすることができます。

- todo 
   1) コードの可読性と整理：関数が長く、多くの処理が含まれています。これを小さな関数に分割して、コードの可読性と保守性を向上させることができます。また、適切なコメントやドキュメンテーションを追加して、他の開発者が理解しやすくすることが重要です。
   2) グローバル変数の使用を避ける：関数がグローバル変数（pre_boxes、pre_keys、pre_scores）を使用しています。これらの変数を関数の引数および戻り値として扱うことで、関数の依存関係を明確にし、再利用可能にすることができます。NumPyのブロードキャスティングを利用する：ループの代わりに、NumPyのブロードキャスティングを利用して、配列の操作を効率的かつ簡潔に記述することができます。
   3) 処理速度の向上：いくつかの部分で、計算速度を向上させるために、より効率的なアルゴリズムやライブラリを検討することができます。例えば、cdistやlinear_sum_assignmentの代わりに、より高速な実装が利用可能な場合があります。
   4) パラメータのチューニングと検証：関数内でハードコードされているいくつかのパラメータ（linger_length、dist_tredなど）があります。これらの値をチューニングして、関数の性能を向上させることができます。また、パラメータを関数の引数として受け取るように変更し、異なる設定で関数を実行できるようにすると、柔軟性が向上します。
   5) エラー処理と入力検証：関数の入力が正しい形式であることを確認し、不適切な入力が与えられた場合に適切なエラーメッセージを表示することで、関数の堅牢性を向上させることができます。

### select_best_candidate関数
この関数は、物体検出や追跡などのアプリケーションで、複数の候補が存在する場合に、最適な候補を効率的に選択するために使用されます。select_best_candidate関数は、与えられたマッチングデータ（ボックス、キー、スコア、速度）をもとに、最適な候補の選択を行います。この関数は、指定されたメトリック（デフォルトでは'score'）と上位k個の要素に基づいて絞り込みを行い、最終的に選択された候補のデータを返します。

具体的な処理の流れは以下の通りです。

まず、matched_boxesが空の場合は、入力されたマッチングデータをそのまま返します。
matched_scoresを用いて、要素を降順にソート（スコアが高い順）します。
上位top_k[0]（デフォルトでは5）個の要素を保持し、それ以外の要素を除外します。
続いて、matched_velocitiesを用いて、要素を降順にソート（速度が高い順）します。
速度が120を超える要素は除外します。
上位top_k[1]（デフォルトでは4）個の要素を保持し、それ以外の要素を除外します。
最終的に、選択されたマッチングデータ（ボックス、キー、スコア、速度）を返します。


- #### 引数
 ```
   matched_boxes: numpy.ndarray。マッチングされたボックスのリスト。
   matched_keys: numpy.ndarray。マッチングされたキーのリスト。
   matched_scores: numpy.ndarray。マッチングされたスコアのリスト。
   matched_velocities: numpy.ndarray。マッチングされた速度のリスト。
   metric: str。使用するメトリック。現在は'score'のみサポートされています。
   top_k: list。上位k個の要素を選択するためのリスト。デフォルトでは[5, 4]。
```

#### 返り値
```
matched_boxes: numpy.ndarray。選択されたボックスのリスト。
matched_keys: numpy.ndarray。選択されたキーのリスト。
matched_scores: numpy.ndarray。選択されたスコアのリスト。
matched_velocities: numpy.ndarray。選択された速度のリスト。
```

#### 処理の流れ
select_best_candidate関数の主な目的は、マッチングデータ（ボックス、キー、スコア、速度）をもとに、最適な候補を選択することです。このアルゴリズムは、スコアや速度の情報を利用して、複数のフィルタリングステージを経ることで、最適な候補を選択します。

アルゴリズムの手順は以下の通りです。

1. **スコアによるソート**: まず、マッチングされたスコアに基づいて、降順（スコアが高い順）にソートします。このステージでは、信頼性の高い候補を選択することが目的です。
2. **上位k個の候補の選択**（1st stage）: スコアが高い順にソートされた候補から、上位top_k[0]（デフォルトでは5）個の候補を選択します。このステージでは、スコアに基づいて最も信頼性の高い候補を選択します。
3. **速度によるソート** : 次に、マッチングされた速度に基づいて、降順（速度が高い順）にソートします。このステージでは、動いている物体を優先的に選択することが目的です。
4. **速度フィルタリング** : 速度が一定の閾値（例：120）を超える候補は、速度が大きすぎると判断し、除外します。これにより、過剰な速度の候補を排除することができます。
5. **上位k個の候補の選択**（2nd stage）: 速度が高い順にソートされた候補から、上位top_k[1]（デフォルトでは4）個の候補を選択します。このステージでは、速度に基づいて最も適切な候補を選択します。
6. **最適な候補の選択** : これらのフィルタリングステージを経て選択された候補が、最適な候補として返されます。このアルゴリズムによって、スコアと速度の両方に基づいて、物体検出や追跡タスクで最適な候補が選択されます。

#### select_best_candidate関数の現状と課題
このアルゴリズムの利点は、複数の基準（スコアと速度）を組み合わせることで、最適な候補を効率的に選択できる点です。また、フィルタリングのステージを2つに分けることで、異なる基準に基づいて候補を絞り込むことができます。これにより、物体検出や追跡タスクの性能が向上し、精度の高い結果が得られます。
またアルゴリズムは、データセットやアプリケーションに応じて、フィルタリングの閾値や上位k個の値を調整することで、さらに最適化することが可能です。アプリケーションの特性や要件に合わせて、パラメータをチューニングすることで、最適な候補選択を実現できます。

他方現状では下記の問題があります。

 * パラメータの調整: 上位k個の値や速度の閾値など、アルゴリズムにおけるパラメータが固定されています。異なるデータセットやアプリケーションに対して最適な結果を得るためには、これらのパラメータを適切に調整する必要があります。パラメータの調整が不十分な場合、適切な候補が選択されず、性能が低下する可能性があります。
* ヒューリスティックなアプローチ: このアルゴリズムはヒューリスティックなアプローチを採用しており、最適な候補の選択はスコアと速度の情報に基づいています。このため、他の重要な特徴が考慮されない場合があります。複雑なシーンや状況に対応するには、より高度なアルゴリズムや機械学習モデルを使用することが望ましいでしょう。
* 計算コスト: アルゴリズムの複数のフィルタリングステージで、ソートやフィルタリングが繰り返し行われます。大規模なデータセットや高速なリアルタイム処理が必要な場合、計算コストが高くなる可能性があります。効率的なアルゴリズムを検討することで、計算コストを削減することができます。
* ロバスト性の欠如: このアルゴリズムは、スコアや速度に大きく依存しています。これらの値がノイズによって大きく影響を受ける場合、適切な候補が選択されない可能性があります。ノイズの影響を抑えるために、ロバストなアルゴリズムや前処理手法を検討することが重要です。


## visualize_candidate 関数の詳細な説明

### 概要
`visualize_candidate`関数は、マッチングされたボックス、キー、スコア、速度を元に、候補の可視化を行います。関数は、画像に候補のボックス、キー、スコア、速度を描画し、最終的な画像を指定されたディレクトリに保存します。

### 引数

- `im`: numpy.ndarray。処理対象の画像。
- `matched_boxes`: numpy.ndarray。マッチングされたボックスのリスト。
- `matched_keys`: numpy.ndarray。マッチングされたキーのリスト。
- `matched_scores`: numpy.ndarray。マッチングされたスコアのリスト。
- `matched_velocities`: numpy.ndarray。マッチングされた速度のリスト。
- `output_dir`: str。画像を保存するディレクトリのパス。
- `frame_id`: int。フレームID。
- `score_th`: float。スコアの閾値（デフォルトでは0.4）。

### 処理の流れ

1. 画像のサイズと中心点を取得します。
2. 各マッチングデータに対して、以下の処理を行います。
   - スコアが閾値以下の場合、処理をスキップします。
   - ボックスが画像の範囲外の場合、処理をスキップします。
   - ボックスのインデックス、スコア、速度を描画します。
   - キーに基づいて矩形を描画します。
3. 画像をリサイズして、指定されたディレクトリに保存します。